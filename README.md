# refactoring

# قسمت دوم

## اعمال الگوی facade

برای اینکار یک کلاس facade برای عملکرد اصلی خود MiniJava که در Main از آن استفاده شده بود، ایجاد کردیم. آنجا مجبور بودیم از پارسر استفاده کنیم و یک اسکنر بسازیم و در نهایت ارور هندلینگ را هم انجام دهیم. هر جای دیگر هم اگر میخواستیم این استفاده را تکرار کنیم، باید همین مراحل را طی میکردیم. اما با ساخت MiniJavaFacade یک اینترفیس مشخص و مینیمال برای compile در اختیار کلاینت که در اینجا Main است قرار دادیم.

## استفاده از polymorphism

در کلاس MiniJava.parser.Action تابع زیر وجود دارد:

```java
public String toString() {
    switch (action) {
        case accept:
            return "acc";
        case shift:
            return "s" + number;
        case reduce:
            return "r" + number;
    }
    return action.toString() + number;
}
```

این تابع می‌تواند با یک polymorphism جایگزین شود. علاوه بر این فیلد number در نوع accept استفاده‌ای ندارد و همچنین در shift و reduce دو مفهوم متفاوت است. لذا در کل بهتر است این کلاس را به ۳ زیر کلاس تبدیل کنیم.

## seperate query from modifier

این پروژه code smell خاصی در این رابطه نداشت صرفا برای انجام کار مشابه، کلاس gettemp در memory.java را که هم آدرس temp را بر میگرداند هم نشانگر آن را جلو میبرد را به دو تابع peeknexttemp و allocatetemp به عنوان query و modifier تقسیم کردیم. اما احتمالا در اینجا بهتر بود همان حالت قبلی حفظ شود چون همیشه در استفادۀ ما این دو با هم رخ میدادند و کد کوتاهی هم داشتند. با تغییر فعلی همۀ gettemp های یک خطی قبلیمان به سه خط تبدیل شدند.

## extract method

دقیقا برای همان بدی ای که در مورد بالا ذکر شد، میتوانیم سه خط تکرارپذیری که برای allocation و دریافت آدرس temp استفاده میشد را به عنوان یک متد استخراج کنیم و همه جا از آن استفاده کنیم. متد allocateTempOf اینکار را برای ما انجام میدهد.

## Self Encapsulate Field

در کلاس Memory برای فیلد codeblock یک protected getter اضافه کردیم و در دیگر قسمت‌های کلاس از آن استفاده نمودیم. همچنین برای کلاس داخلی \_3AddressCode مشابه این کار را انجام دادیم. توجه شود که در این کلاس داخلی، فیلد‌ها نیز به صورت public تعریف شده‌بودند که آن‌ها نیز به حالت private تغییر داده شدند.


# سوالات

## 4 اصول SOLID در الگوی Factory Method
### Single Responsibility
این اصل در این الگو رعایت می‌شود چون وظیفه ساخت یک شی جدید از استفاده کنندگان برداشته می‌شود و فقط به فکتوری متد داده می‌شود
### Open/Close
تا حدی رعایت می‌شود. زیرا بدون تغییر استفاده کنندگان، می‌توان کلاس‌های جدیدی را اضافه کرد. البته برای اضافه کردن هر کلاس جدید احتمالا Factory Method هم باید تغییر کند.
### Liskov Substitution
رعایت می‌شود زیرا تمام اشیایی که توسط Factory Method تولید می‌شوند، از یک اینترفیس یا کلاس پیروی می‌کنند و می‌توانند جایگزین یکدیگر شوند.
### Interface Segregation
به طور مستقیم ارتباطی ندارند
### Dependency Inversion
رعایت می‌شود. چون استفاده‌کنندگان به جای وابستگی به پیاده‌سازی خاص به یک کلاس پایه وابستگی دارند و وابستگی‌ها به لایه بالا منتقل می‌شود.

## ۲ دسته‌بندی بوهای بد
### Bloaters
اینها بوی کد ناشی از رشد بیش از حد عناصر کد مانند کلاس‌ها، متد‌ها یا لیست پارامترها هستند. آنها مدیریت و درک کد را در طول زمان دشوارتر می کنند. به عنوان مثال می توان long method و large class اشاره کرد.
### Object-Orientation Abusers
این بوهای بد زمانی رخ می‌دهند که اصول طراحی شی گرا به صورت اشتباه استفاده شود که می‌تواند منجر به طراحی غلط شود. مانند Switch Statement و Refused Bequest
### Change Preventers
این نوع بوها نشان می‌دهند که تغییر دادن کد پیچیدگی دارد و در نتیجه نگه‌داری و توسعه کد هزینه بیشتری دارد. مانند Divergent Change و Shotgun Surgery
### Dispensables
این بو نشان می‌دهد که چیزی در کد بدون استفاده است و وجود آن فایده‌ای برای کد ندارد. در نتیجه حذف آن باعث کارایی بهتر یا خوانایی بهتر کد می‌شود. مانند Duplicate Code و Dead Code
### Couples
این بوها نشان می‌دهد که دو کلاس یا کامپوننت وابستگی زیادی به یکدیگر دارند و تغییر سیستم را سخت می‌کنند. مانند Feature Envy و Middle Man

## ۱۰ بوی بد از پروژه تبدیل کننده مدل به سی
   1. large class: کلاس Main کلاسی است که فیلدها و توابع زیادی دارد و نگه‌داری و توسعه آن بسیار سخت است
   2. long method: خود تابع main در این کلاس بزرگ است. این تابع می‌تواند به تابع‌های کوچک‌تر شکسته شود.
   3. duplicate code: در کلاس Phase1CodeGenerator فرایند نوشتن فایل چندین بار تکرار شده و می‌توان بجای آن یک تابع خارج کرد و از آن استفاده کرد.
   4. dead code: در تمام کد، بخش‌های زیادی وجود دارند که کدهایی کامنت شده‌اند و خوانایی را پایین می‌آورند.
   5. magic strings: در کلاس LexicalAnalyzer از رشته‌هایی مثل ".result" یا "unknown.txt" استفاده شده است که می‌توانند تبدیل به یک ثابت با اسم مناسب شوند.
   6. switch statement: در کلاس ClassInfo یک سوییچ وجود دارد که می‌تواند با چندریختی یا state/strategy جایگزین شود.
   7. message chain: در کلاس GUIMethod چنین کدی دیده می‌شود `getReturnValueType().getShowPanel().setVisible(panel.isVisible());` که نشانه message chain است.